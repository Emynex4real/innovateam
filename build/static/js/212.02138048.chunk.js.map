{"version":3,"file":"static/js/212.02138048.chunk.js","mappings":"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","sources":["../node_modules/@radix-ui/react-compose-refs/src/compose-refs.tsx","../node_modules/@radix-ui/react-context/src/create-context.tsx","../node_modules/@radix-ui/primitive/src/primitive.tsx","../node_modules/@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state-reducer.tsx","../node_modules/@radix-ui/react-presence/src/presence.tsx","../node_modules/@radix-ui/react-presence/src/use-state-machine.tsx","../node_modules/@radix-ui/react-checkbox/src/checkbox.tsx","../node_modules/@radix-ui/react-use-previous/src/use-previous.tsx","../node_modules/@radix-ui/react-use-size/src/use-size.tsx","../node_modules/@radix-ui/react-primitive/src/primitive.tsx","../node_modules/@radix-ui/react-slot/src/slot.tsx","../node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../node_modules/framer-motion/dist/es/utils/use-force-update.mjs","../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs","../node_modules/@radix-ui/react-label/src/label.tsx","../node_modules/lucide-react/src/icons/check.ts"],"sourcesContent":["import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n","import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n","function composeEventHandlers<E extends { defaultPrevented: boolean }>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n","import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// Prevent bundlers from trying to optimize the import\nconst useInsertionEffect: typeof useLayoutEffect =\n  (React as any)[' useInsertionEffect '.trim().toString()] || useLayoutEffect;\n\ntype ChangeHandler<T> = (state: T) => void;\ntype SetStateFn<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseControllableStateParams<T> {\n  prop?: T | undefined;\n  defaultProp: T;\n  onChange?: ChangeHandler<T>;\n  caller?: string;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n  caller,\n}: UseControllableStateParams<T>): [T, SetStateFn<T>] {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(prop !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  const setValue = React.useCallback<SetStateFn<T>>(\n    (nextValue) => {\n      if (isControlled) {\n        const value = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value !== prop) {\n          onChangeRef.current?.(value);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n\n  return [value, setValue];\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>): [\n  Value: T,\n  setValue: React.Dispatch<React.SetStateAction<T>>,\n  OnChangeRef: React.RefObject<ChangeHandler<T> | undefined>,\n] {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n\n  return [value, setValue, onChangeRef];\n}\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","import * as React from 'react';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype ChangeHandler<T> = (state: T) => void;\n\ninterface UseControllableStateParams<T> {\n  prop: T | undefined;\n  defaultProp: T;\n  onChange: ChangeHandler<T> | undefined;\n  caller: string;\n}\n\ninterface AnyAction {\n  type: string;\n}\n\nconst SYNC_STATE = Symbol('RADIX:SYNC_STATE');\n\ninterface SyncStateAction<T> {\n  type: typeof SYNC_STATE;\n  state: T;\n}\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialState: S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, I, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: I,\n  init: (i: I & { state: T }) => S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: any,\n  init?: (i: any) => Omit<S, 'state'>\n): [S & { state: T }, React.Dispatch<A>] {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== undefined;\n\n  const onChange = useEffectEvent(onChangeProp);\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(controlledState !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  type InternalState = S & { state: T };\n  const args: [InternalState] = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    // @ts-expect-error\n    args.push(init);\n  }\n\n  const [internalState, dispatch] = React.useReducer(\n    (state: InternalState, action: A | SyncStateAction<T>): InternalState => {\n      if (action.type === SYNC_STATE) {\n        return { ...state, state: action.state };\n      }\n\n      const next = reducer(state, action);\n      if (isControlled && !Object.is(next.state, state.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React.useRef(uncontrolledState);\n  React.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n\n  const state = React.useMemo(() => {\n    const isControlled = controlledState !== undefined;\n    if (isControlled) {\n      return { ...internalState, state: controlledState };\n    }\n\n    return internalState;\n  }, [internalState, controlledState]);\n\n  React.useEffect(() => {\n    // Sync internal state for controlled components so that reducer is called\n    // with the correct state values\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n\n  return [state, dispatch as React.Dispatch<A>];\n}\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './use-state-machine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration | null>(null);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      stylesRef.current = node ? getComputedStyle(node) : null;\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles: CSSStyleDeclaration | null) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Presence;\n\nexport {\n  Presence,\n  //\n  Root,\n};\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst CHECKBOX_NAME = 'Checkbox';\n\ntype ScopedProps<P> = P & { __scopeCheckbox?: Scope };\nconst [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\n\ntype CheckedState = boolean | 'indeterminate';\n\ntype CheckboxContextValue<State extends CheckedState | boolean = CheckedState> = {\n  checked: State | boolean;\n  setChecked: React.Dispatch<React.SetStateAction<State | boolean>>;\n  disabled: boolean | undefined;\n  control: HTMLButtonElement | null;\n  setControl: React.Dispatch<React.SetStateAction<HTMLButtonElement | null>>;\n  name: string | undefined;\n  form: string | undefined;\n  value: string | number | readonly string[];\n  hasConsumerStoppedPropagationRef: React.RefObject<boolean>;\n  required: boolean | undefined;\n  defaultChecked: boolean | undefined;\n  isFormControl: boolean;\n  bubbleInput: HTMLInputElement | null;\n  setBubbleInput: React.Dispatch<React.SetStateAction<HTMLInputElement | null>>;\n};\n\nconst [CheckboxProviderImpl, useCheckboxContext] =\n  createCheckboxContext<CheckboxContextValue>(CHECKBOX_NAME);\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxProvider\n * -----------------------------------------------------------------------------------------------*/\n\ninterface CheckboxProviderProps<State extends CheckedState = CheckedState> {\n  checked?: State | boolean;\n  defaultChecked?: State | boolean;\n  required?: boolean;\n  onCheckedChange?(checked: State | boolean): void;\n  name?: string;\n  form?: string;\n  disabled?: boolean;\n  value?: string | number | readonly string[];\n  children?: React.ReactNode;\n}\n\nfunction CheckboxProvider<State extends CheckedState = CheckedState>(\n  props: ScopedProps<CheckboxProviderProps<State>>\n) {\n  const {\n    __scopeCheckbox,\n    checked: checkedProp,\n    children,\n    defaultChecked,\n    disabled,\n    form,\n    name,\n    onCheckedChange,\n    required,\n    value = 'on',\n    // @ts-expect-error\n    internal_do_not_use_render,\n  } = props;\n\n  const [checked, setChecked] = useControllableState({\n    prop: checkedProp,\n    defaultProp: defaultChecked ?? false,\n    onChange: onCheckedChange,\n    caller: CHECKBOX_NAME,\n  });\n  const [control, setControl] = React.useState<HTMLButtonElement | null>(null);\n  const [bubbleInput, setBubbleInput] = React.useState<HTMLInputElement | null>(null);\n  const hasConsumerStoppedPropagationRef = React.useRef(false);\n  const isFormControl = control\n    ? !!form || !!control.closest('form')\n    : // We set this to true by default so that events bubble to forms without JS (SSR)\n      true;\n\n  const context: CheckboxContextValue<State> = {\n    checked: checked,\n    disabled: disabled,\n    setChecked: setChecked,\n    control: control,\n    setControl: setControl,\n    name: name,\n    form: form,\n    value: value,\n    hasConsumerStoppedPropagationRef: hasConsumerStoppedPropagationRef,\n    required: required,\n    defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,\n    isFormControl: isFormControl,\n    bubbleInput,\n    setBubbleInput,\n  };\n\n  return (\n    <CheckboxProviderImpl\n      scope={__scopeCheckbox}\n      {...(context as unknown as CheckboxContextValue<CheckedState>)}\n    >\n      {isFunction(internal_do_not_use_render) ? internal_do_not_use_render(context) : children}\n    </CheckboxProviderImpl>\n  );\n}\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'CheckboxTrigger';\n\ninterface CheckboxTriggerProps\n  extends Omit<\n    React.ComponentPropsWithoutRef<typeof Primitive.button>,\n    keyof CheckboxProviderProps\n  > {\n  children?: React.ReactNode;\n}\n\nconst CheckboxTrigger = React.forwardRef<HTMLButtonElement, CheckboxTriggerProps>(\n  (\n    { __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }: ScopedProps<CheckboxTriggerProps>,\n    forwardedRef\n  ) => {\n    const {\n      control,\n      value,\n      disabled,\n      checked,\n      required,\n      setControl,\n      setChecked,\n      hasConsumerStoppedPropagationRef,\n      isFormControl,\n      bubbleInput,\n    } = useCheckboxContext(TRIGGER_NAME, __scopeCheckbox);\n    const composedRefs = useComposedRefs(forwardedRef, setControl);\n\n    const initialCheckedStateRef = React.useRef(checked);\n    React.useEffect(() => {\n      const form = control?.form;\n      if (form) {\n        const reset = () => setChecked(initialCheckedStateRef.current);\n        form.addEventListener('reset', reset);\n        return () => form.removeEventListener('reset', reset);\n      }\n    }, [control, setChecked]);\n\n    return (\n      <Primitive.button\n        type=\"button\"\n        role=\"checkbox\"\n        aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n        aria-required={required}\n        data-state={getState(checked)}\n        data-disabled={disabled ? '' : undefined}\n        disabled={disabled}\n        value={value}\n        {...checkboxProps}\n        ref={composedRefs}\n        onKeyDown={composeEventHandlers(onKeyDown, (event) => {\n          // According to WAI ARIA, Checkboxes don't activate on enter keypress\n          if (event.key === 'Enter') event.preventDefault();\n        })}\n        onClick={composeEventHandlers(onClick, (event) => {\n          setChecked((prevChecked) => (isIndeterminate(prevChecked) ? true : !prevChecked));\n          if (bubbleInput && isFormControl) {\n            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n            // if checkbox has a bubble input and is a form control, stop\n            // propagation from the button so that we only propagate one click\n            // event (from the input). We propagate changes from an input so\n            // that native form validation works and form events reflect\n            // checkbox updates.\n            if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n          }\n        })}\n      />\n    );\n  }\n);\n\nCheckboxTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Checkbox\n * -----------------------------------------------------------------------------------------------*/\n\ntype CheckboxElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface CheckboxProps extends Omit<PrimitiveButtonProps, 'checked' | 'defaultChecked'> {\n  checked?: CheckedState;\n  defaultChecked?: CheckedState;\n  required?: boolean;\n  onCheckedChange?(checked: CheckedState): void;\n}\n\nconst Checkbox = React.forwardRef<CheckboxElement, CheckboxProps>(\n  (props: ScopedProps<CheckboxProps>, forwardedRef) => {\n    const {\n      __scopeCheckbox,\n      name,\n      checked,\n      defaultChecked,\n      required,\n      disabled,\n      value,\n      onCheckedChange,\n      form,\n      ...checkboxProps\n    } = props;\n\n    return (\n      <CheckboxProvider\n        __scopeCheckbox={__scopeCheckbox}\n        checked={checked}\n        defaultChecked={defaultChecked}\n        disabled={disabled}\n        required={required}\n        onCheckedChange={onCheckedChange}\n        name={name}\n        form={form}\n        value={value}\n        // @ts-expect-error\n        internal_do_not_use_render={({ isFormControl }: CheckboxContextValue) => (\n          <>\n            <CheckboxTrigger\n              {...checkboxProps}\n              ref={forwardedRef}\n              // @ts-expect-error\n              __scopeCheckbox={__scopeCheckbox}\n            />\n            {isFormControl && (\n              <CheckboxBubbleInput\n                // @ts-expect-error\n                __scopeCheckbox={__scopeCheckbox}\n              />\n            )}\n          </>\n        )}\n      />\n    );\n  }\n);\n\nCheckbox.displayName = CHECKBOX_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'CheckboxIndicator';\n\ntype CheckboxIndicatorElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface CheckboxIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst CheckboxIndicator = React.forwardRef<CheckboxIndicatorElement, CheckboxIndicatorProps>(\n  (props: ScopedProps<CheckboxIndicatorProps>, forwardedRef) => {\n    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;\n    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n    return (\n      <Presence\n        present={forceMount || isIndeterminate(context.checked) || context.checked === true}\n      >\n        <Primitive.span\n          data-state={getState(context.checked)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n          style={{ pointerEvents: 'none', ...props.style }}\n        />\n      </Presence>\n    );\n  }\n);\n\nCheckboxIndicator.displayName = INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxBubbleInput\n * -----------------------------------------------------------------------------------------------*/\n\nconst BUBBLE_INPUT_NAME = 'CheckboxBubbleInput';\n\ntype InputProps = React.ComponentPropsWithoutRef<typeof Primitive.input>;\ninterface CheckboxBubbleInputProps extends Omit<InputProps, 'checked'> {}\n\nconst CheckboxBubbleInput = React.forwardRef<HTMLInputElement, CheckboxBubbleInputProps>(\n  ({ __scopeCheckbox, ...props }: ScopedProps<CheckboxBubbleInputProps>, forwardedRef) => {\n    const {\n      control,\n      hasConsumerStoppedPropagationRef,\n      checked,\n      defaultChecked,\n      required,\n      disabled,\n      name,\n      value,\n      form,\n      bubbleInput,\n      setBubbleInput,\n    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);\n\n    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);\n    const prevChecked = usePrevious(checked);\n    const controlSize = useSize(control);\n\n    // Bubble checked change to parents (e.g form change event)\n    React.useEffect(() => {\n      const input = bubbleInput;\n      if (!input) return;\n\n      const inputProto = window.HTMLInputElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        inputProto,\n        'checked'\n      ) as PropertyDescriptor;\n      const setChecked = descriptor.set;\n\n      const bubbles = !hasConsumerStoppedPropagationRef.current;\n      if (prevChecked !== checked && setChecked) {\n        const event = new Event('click', { bubbles });\n        input.indeterminate = isIndeterminate(checked);\n        setChecked.call(input, isIndeterminate(checked) ? false : checked);\n        input.dispatchEvent(event);\n      }\n    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);\n\n    const defaultCheckedRef = React.useRef(isIndeterminate(checked) ? false : checked);\n    return (\n      <Primitive.input\n        type=\"checkbox\"\n        aria-hidden\n        defaultChecked={defaultChecked ?? defaultCheckedRef.current}\n        required={required}\n        disabled={disabled}\n        name={name}\n        value={value}\n        form={form}\n        {...props}\n        tabIndex={-1}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          ...controlSize,\n          position: 'absolute',\n          pointerEvents: 'none',\n          opacity: 0,\n          margin: 0,\n          // We transform because the input is absolutely positioned but we have\n          // rendered it **after** the button. This pulls it back to sit on top\n          // of the button.\n          transform: 'translateX(-100%)',\n        }}\n      />\n    );\n  }\n);\n\nCheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nexport {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxProvider,\n  CheckboxTrigger,\n  CheckboxIndicator,\n  CheckboxBubbleInput,\n  //\n  Checkbox as Root,\n  CheckboxProvider as Provider,\n  CheckboxTrigger as Trigger,\n  CheckboxIndicator as Indicator,\n  CheckboxBubbleInput as BubbleInput,\n};\nexport type {\n  CheckboxProps,\n  CheckboxProviderProps,\n  CheckboxTriggerProps,\n  CheckboxIndicatorProps,\n  CheckboxBubbleInputProps,\n  CheckedState,\n};\n","import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n","/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nfunction useSize(element: HTMLElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  useLayoutEffect(() => {\n    if (element) {\n      // provide size as early as possible\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate it ourselves to get the correct border box.\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => resizeObserver.unobserve(element);\n    } else {\n      // We only want to reset to `undefined` when the element becomes `null`,\n      // not if it changes to another element.\n      setSize(undefined);\n    }\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { createSlot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'select',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not necessary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click 👎\n * target.dispatchEvent(new Event(‘click’))\n *\n * dispatching a custom type within a non-discrete event 👎\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(‘customType’))}\n *\n * dispatching a custom type within a `discrete` event 👍\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(‘customType’))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n","import { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    const isMounted = useRef(false);\n    useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n","import * as React from 'react';\nimport { useId, useRef, useInsertionEffect } from 'react';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n    });\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        document.head.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            top: ${top}px !important;\n            left: ${left}px !important;\n          }\n        `);\n        }\n        return () => {\n            document.head.removeChild(style);\n        };\n    }, [isPresent]);\n    return (React.createElement(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size }, React.cloneElement(children, { ref })));\n}\n\nexport { PopChild };\n","import * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    const context = useMemo(() => ({\n        id,\n        initial,\n        isPresent,\n        custom,\n        onExitComplete: (childId) => {\n            presenceChildren.set(childId, true);\n            for (const isComplete of presenceChildren.values()) {\n                if (!isComplete)\n                    return; // can stop searching when any is incomplete\n            }\n            onExitComplete && onExitComplete();\n        },\n        register: (childId) => {\n            presenceChildren.set(childId, false);\n            return () => presenceChildren.delete(childId);\n        },\n    }), \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = React.createElement(PopChild, { isPresent: isPresent }, children);\n    }\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { invariant } from '../../utils/errors.mjs';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n    children.forEach((child) => {\n        const key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\", }) => {\n    invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    const forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\n    const isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    const filteredChildren = onlyElements(children);\n    let childrenToRender = filteredChildren;\n    const exitingChildren = useRef(new Map()).current;\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    const presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    const allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    const isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(() => {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exitingChildren.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map((child) => (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child)))));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = [...childrenToRender];\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    const presentKeys = presentChildren.current.map(getChildKey);\n    const targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    const numPresent = presentKeys.length;\n    for (let i = 0; i < numPresent; i++) {\n        const key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n            exitingChildren.set(key, undefined);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (mode === \"wait\" && exitingChildren.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exitingChildren.forEach((component, key) => {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        const child = allChildren.get(key);\n        if (!child)\n            return;\n        const insertionIndex = presentKeys.indexOf(key);\n        let exitingComponent = component;\n        if (!exitingComponent) {\n            const onExit = () => {\n                // clean up the exiting children map\n                exitingChildren.delete(key);\n                // compute the keys of children that were rendered once but are no longer present\n                // this could happen in case of too many fast consequent renderings\n                // @link https://github.com/framer/motion/issues/2023\n                const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));\n                // clean up the all children map\n                leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));\n                // make sure to render only the children that are actually visible\n                presentChildren.current = filteredChildren.filter((presentChild) => {\n                    const presentChildKey = getChildKey(presentChild);\n                    return (\n                    // filter out the node exiting\n                    presentChildKey === key ||\n                        // filter out the leftover children\n                        leftOverKeys.includes(presentChildKey));\n                });\n                // Defer re-rendering until all exiting children have indeed left\n                if (!exitingChildren.size) {\n                    if (isMounted.current === false)\n                        return;\n                    forceRender();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            exitingComponent = (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\n            exitingChildren.set(key, exitingComponent);\n        }\n        childrenToRender.splice(insertionIndex, 0, exitingComponent);\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map((child) => {\n        const key = child.key;\n        return exitingChildren.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\n    });\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        childrenToRender.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    return (React.createElement(React.Fragment, null, exitingChildren.size\n        ? childrenToRender\n        : childrenToRender.map((child) => cloneElement(child))));\n};\n\nexport { AnimatePresence };\n","import { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\nfunction useForceUpdate() {\n    const isMounted = useIsMounted();\n    const [forcedRenderCount, setForcedRenderCount] = useState(0);\n    const forceRender = useCallback(() => {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    const deferredForceRender = useCallback(() => frame.postRender(forceRender), [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n","import { useEffect } from 'react';\n\nfunction useUnmountEffect(callback) {\n    return useEffect(() => () => callback(), []);\n}\n\nexport { useUnmountEffect };\n","import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Label\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Label';\n\ntype LabelElement = React.ComponentRef<typeof Primitive.label>;\ntype PrimitiveLabelProps = React.ComponentPropsWithoutRef<typeof Primitive.label>;\ninterface LabelProps extends PrimitiveLabelProps {}\n\nconst Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {\n  return (\n    <Primitive.label\n      {...props}\n      ref={forwardedRef}\n      onMouseDown={(event) => {\n        // only prevent text selection if clicking inside the label itself\n        const target = event.target as HTMLElement;\n        if (target.closest('button, input, select, textarea')) return;\n\n        props.onMouseDown?.(event);\n        // prevent text selection when double clicking label\n        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n      }}\n    />\n  );\n});\n\nLabel.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Label;\n\nexport {\n  Label,\n  //\n  Root,\n};\nexport type { LabelProps };\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Check\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjAgNiA5IDE3bC01LTUiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/check\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Check = createLucideIcon('Check', [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]]);\n\nexport default Check;\n"],"names":["setRef","ref","value","current","composeRefs","_len","arguments","length","refs","Array","_key","node","hasCleanup","cleanups","map","cleanup","i","useComposedRefs","_len2","_key2","React","composeContextScopes","scopes","baseScope","createScope","scopeHooks","createScope2","useScope","scopeName","overrideScopes","nextScopes","reduce","nextScopes2","_ref","currentScope","concat","_objectSpread","composeEventHandlers","originalEventHandler","ourEventHandler","checkForDefaultPrevented","undefined","event","defaultPrevented","useLayoutEffect2","globalThis","document","useInsertionEffect","trim","toString","useLayoutEffect","useControllableState","prop","defaultProp","onChange","caller","uncontrolledProp","setUncontrolledProp","onChangeRef","_ref2","setValue","prevValueRef","_onChangeRef$current2","call","useUncontrolledState","isControlled","isControlledRef","wasControlled","from","to","console","warn","nextValue","value2","isFunction","_onChangeRef$current","Symbol","Presence","props","present","children","presence","setNode","React2","stylesRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","machine","nextState","useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","currentAnimationName","getAnimationName","styles","wasPresent","prevAnimationName","display","_node$ownerDocument$d","timeoutId","ownerWindow","ownerDocument","defaultView","window","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","currentFillMode","style","animationFillMode","setTimeout","handleAnimationStart","addEventListener","clearTimeout","removeEventListener","isPresent","node2","getComputedStyle","usePresence","child","only","element","_Object$getOwnPropert","_Object$getOwnPropert2","getter","Object","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","getElementRef","displayName","CHECKBOX_NAME","createCheckboxContext","createCheckboxScope","createContextScopeDeps","defaultContexts","scopeContexts","defaultContext","scope","contexts","rootComponentName","BaseContext","index","Provider","_scope$scopeName","context","_objectWithoutProperties","_excluded2","Context","values","jsx","consumerName","_scope$scopeName2","Error","createContextScope","CheckboxProviderImpl","useCheckboxContext","CheckboxProvider","__scopeCheckbox","checked","checkedProp","defaultChecked","disabled","form","name","onCheckedChange","required","internal_do_not_use_render","setChecked","control","setControl","bubbleInput","setBubbleInput","hasConsumerStoppedPropagationRef","isFormControl","closest","isIndeterminate","TRIGGER_NAME","CheckboxTrigger","forwardedRef","onKeyDown","onClick","checkboxProps","_excluded","composedRefs","initialCheckedStateRef","reset","Primitive","button","type","role","getState","key","preventDefault","prevChecked","isPropagationStopped","stopPropagation","Checkbox","jsxs","Fragment","CheckboxBubbleInput","INDICATOR_NAME","CheckboxIndicator","forceMount","indicatorProps","_excluded3","span","pointerEvents","BUBBLE_INPUT_NAME","_ref3","_excluded4","previous","usePrevious","controlSize","size","setSize","width","offsetWidth","height","offsetHeight","resizeObserver","ResizeObserver","entries","isArray","entry","borderSizeEntry","borderSize","observe","box","unobserve","useSize","input","inputProto","HTMLInputElement","prototype","set","bubbles","Event","indeterminate","dispatchEvent","defaultCheckedRef","tabIndex","position","opacity","margin","transform","primitive","Slot","createSlot","Node","asChild","primitiveProps","Comp","for","ownerName","SlotClone","createSlotClone","Slot2","slotProps","childrenArray","toArray","slottable","find","isSlottable","newElement","newChildren","count","childrenRef","props2","childProps","overrideProps","propName","slotPropValue","childPropValue","test","result","filter","Boolean","join","mergeProps","SLOTTABLE_IDENTIFIER","__radixId","useIsMounted","isMounted","useRef","useIsomorphicLayoutEffect","PopChildMeasure","getSnapshotBeforeUpdate","prevProps","this","childRef","sizeRef","top","offsetTop","left","offsetLeft","componentDidUpdate","render","PopChild","id","useId","dataset","motionPopId","createElement","head","appendChild","sheet","insertRule","removeChild","PresenceChild","initial","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","useConstant","newChildrenMap","useMemo","childId","isComplete","register","delete","forEach","_","PresenceContext","Map","getChildKey","AnimatePresence","exitBeforeEnter","invariant","forceRender","useContext","LayoutGroupContext","forcedRenderCount","setForcedRenderCount","useState","useCallback","frame","postRender","useForceUpdate","filteredChildren","filtered","Children","isValidElement","push","onlyElements","childrenToRender","exitingChildren","presentChildren","allChildren","isInitialRender","callback","updateChildLookup","clear","useEffect","presentKeys","targetKeys","numPresent","indexOf","has","component","insertionIndex","exitingComponent","onExit","leftOverKeys","keys","childKey","leftOverKey","presentChild","presentChildKey","splice","cloneElement","Label","label","onMouseDown","_props$onMouseDown","detail","Root","Check","createLucideIcon","d"],"sourceRoot":""}
/**
 * FORUM SERVICE - PRODUCTION READY
 * Handles all forum operations with proper validation and error handling
 */

const supabase = require('../supabaseClient');
const { logger } = require('../utils/logger');
const cache = require('../utils/cache');

class ForumService {
  
  // ============================================
  // CATEGORIES
  // ============================================
  
  async getCategories(centerId) {
    try {
      if (!centerId) throw new Error('Center ID is required');

      const { data, error } = await supabase
        .from('forum_category_stats')
        .select('*')
        .eq('center_id', centerId)
        .order('display_order', { ascending: true });

      if (error) throw error;

      return { 
        success: true, 
        data: data || [],
        count: data?.length || 0
      };
    } catch (error) {
      logger.error('Error getting categories:', error);
      return { success: false, error: error.message, data: [] };
    }
  }

  async getUserCenter(userId) {
    try {
      // Get user's center from profile or use first available center
      const { data: profile } = await supabase
        .from('user_profiles')
        .select('center_id')
        .eq('id', userId)
        .single();

      if (profile?.center_id) {
        return { success: true, centerId: profile.center_id };
      }

      // Fallback: get first center with forum categories
      const { data: center } = await supabase
        .from('tutorial_centers')
        .select('id')
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      return { success: true, centerId: center?.id || 'dc915189-23f8-4876-b5e7-940b9a001847' };
    } catch (error) {
      logger.error('Error getting user center:', error);
      return { success: true, centerId: 'dc915189-23f8-4876-b5e7-940b9a001847' };
    }
  }

  // ============================================
  // THREADS
  // ============================================
  
  async getThreads(categoryId, page = 1, limit = 20) {
    try {
      if (!categoryId) throw new Error('Category ID is required');

      const offset = (page - 1) * limit;

      const { data, error } = await supabase
        .from('forum_threads_with_author')
        .select('*')
        .eq('category_id', categoryId)
        .order('is_pinned', { ascending: false })
        .order('last_activity_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) throw error;

      return { 
        success: true, 
        data: data || [],
        pagination: {
          page,
          limit,
          hasMore: data?.length === limit
        }
      };
    } catch (error) {
      logger.error('Error getting threads:', error);
      return { success: false, error: error.message, data: [] };
    }
  }

  async getThread(threadId, userId) {
    try {
      if (!threadId) throw new Error('Thread ID is required');

      console.log('üîç Getting thread:', threadId);

      // Get thread
      const { data: thread, error: threadError } = await supabase
        .from('forum_threads_with_author')
        .select('*')
        .eq('id', threadId)
        .single();

      if (threadError) throw threadError;
      if (!thread) throw new Error('Thread not found');

      console.log('üìã Thread data:', JSON.stringify(thread, null, 2));

      // Record view (async)
      this.recordThreadView(threadId, userId).catch(() => {});

      // Get all posts at once
      const { data: allPosts, error: postsError } = await supabase
        .from('forum_posts')
        .select('*')
        .eq('thread_id', threadId)
        .eq('is_deleted', false)
        .order('created_at', { ascending: true });

      if (postsError) throw postsError;

      // Get all unique author IDs
      const authorIds = [...new Set(allPosts?.map(p => p.author_id) || [])];
      
      // Fetch all authors in one query
      const { data: authors } = await supabase
        .from('auth.users')
        .select('id, email, raw_user_meta_data')
        .in('id', authorIds);

      const authorsMap = (authors || []).reduce((acc, author) => {
        acc[author.id] = {
          id: author.id,
          name: author.raw_user_meta_data?.full_name || author.email?.split('@')[0] || 'Anonymous',
          email: author.email,
          avatar_url: author.raw_user_meta_data?.avatar_url
        };
        return acc;
      }, {});

      // Get user votes in one query if userId provided
      let votesMap = {};
      if (userId) {
        const postIds = allPosts?.map(p => p.id) || [];
        const { data: votes } = await supabase
          .from('forum_votes')
          .select('post_id, vote_type')
          .in('post_id', postIds)
          .eq('user_id', userId);
        
        votesMap = (votes || []).reduce((acc, vote) => {
          acc[vote.post_id] = vote.vote_type;
          return acc;
        }, {});
      }

      // Organize posts into parent-child structure
      const postsMap = {};
      const rootPosts = [];

      allPosts?.forEach(post => {
        const enrichedPost = {
          ...post,
          author: authorsMap[post.author_id] || {},
          user_vote: votesMap[post.id] || null,
          replies: []
        };
        postsMap[post.id] = enrichedPost;

        if (!post.parent_post_id) {
          rootPosts.push(enrichedPost);
        }
      });

      // Attach replies to parents
      allPosts?.forEach(post => {
        if (post.parent_post_id && postsMap[post.parent_post_id]) {
          postsMap[post.parent_post_id].replies.push(postsMap[post.id]);
        }
      });

      // Sort root posts
      rootPosts.sort((a, b) => {
        if (a.is_marked_answer !== b.is_marked_answer) {
          return b.is_marked_answer ? 1 : -1;
        }
        if (a.upvote_count !== b.upvote_count) {
          return b.upvote_count - a.upvote_count;
        }
        return new Date(a.created_at) - new Date(b.created_at);
      });

      // Check if following
      let isFollowing = false;
      if (userId) {
        const { data: follow } = await supabase
          .from('forum_thread_followers')
          .select('id')
          .eq('thread_id', threadId)
          .eq('user_id', userId)
          .maybeSingle();
        isFollowing = !!follow;
      }

      const result = {
        ...thread,
        posts: rootPosts,
        is_following: isFollowing
      };

      console.log('‚úÖ Thread loaded with', rootPosts.length, 'posts');

      return { success: true, data: result };
    } catch (error) {
      console.error('‚ùå Error:', error.message);
      logger.error('Error getting thread:', error);
      return { success: false, error: error.message, data: null };
    }
  }

  async createThread(categoryId, centerId, creatorId, title, description, tags = []) {
    try {
      // Validation
      if (!categoryId || !centerId || !creatorId) {
        throw new Error('Missing required fields');
      }
      if (!title?.trim() || title.length < 10) {
        throw new Error('Title must be at least 10 characters');
      }
      if (!description?.trim() || description.length < 20) {
        throw new Error('Description must be at least 20 characters');
      }

      // Generate slug
      const slug = this.generateSlug(title);

      const { data: thread, error } = await supabase
        .from('forum_threads')
        .insert({
          category_id: categoryId,
          center_id: centerId,
          creator_id: creatorId,
          title: title.trim(),
          description: description.trim(),
          slug,
          tags: tags || []
        })
        .select()
        .single();

      console.log('üìù Thread insert result:', { thread, error });

      if (error) throw error;
      if (!thread) throw new Error('Failed to create thread');

      // Auto-follow thread (safe handling)
      try {
        const followResult = await this.followThread(thread.id, creatorId);
        console.log('üìå Follow result:', followResult);
        if (followResult?.error) {
          logger.warn(`Auto-follow failed: ${followResult.error}`);
        }
      } catch (err) {
        logger.warn(`Auto-follow crashed: ${err.message}`);
      }

      // Update reputation (fire and forget)
      this.updateReputation(creatorId, centerId, 'thread_created').catch(err => 
        logger.debug(`Reputation update failed: ${err.message}`)
      );

      logger.info(`Thread created: ${thread.id} by user ${creatorId}`);
      return { success: true, data: thread };
    } catch (error) {
      logger.error('Error creating thread:', error);
      return { success: false, error: error.message };
    }
  }

  async searchThreads(centerId, query, page = 1, limit = 20) {
    try {
      if (!centerId || !query?.trim()) {
        throw new Error('Center ID and search query are required');
      }

      const offset = (page - 1) * limit;
      const searchTerm = query.trim();

      const { data, error } = await supabase
        .from('forum_threads_with_author')
        .select('*')
        .eq('center_id', centerId)
        .or(`title.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)
        .order('last_activity_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) throw error;

      return { 
        success: true, 
        data: data || [],
        query: searchTerm,
        pagination: { page, limit, hasMore: data?.length === limit }
      };
    } catch (error) {
      logger.error('Error searching threads:', error);
      return { success: false, error: error.message, data: [] };
    }
  }

  // ============================================
  // POSTS
  // ============================================
  
  async createPost(threadId, authorId, content, parentPostId = null) {
    try {
      // Validation
      if (!threadId || !authorId) throw new Error('Missing required fields');
      if (!content?.trim() || content.length < 5) {
        throw new Error('Post must be at least 5 characters');
      }

      // Check if thread is locked
      const { data: thread } = await supabase
        .from('forum_threads')
        .select('is_locked, center_id')
        .eq('id', threadId)
        .single();

      if (thread?.is_locked) {
        throw new Error('This thread is locked');
      }

      const result = await supabase
        .from('forum_posts')
        .insert({
          thread_id: threadId,
          author_id: authorId,
          content: content.trim(),
          parent_post_id: parentPostId
        })
        .select()
        .single();

      console.log('üìù Post insert result:', result);

      if (result?.error) throw result.error;
      if (!result?.data) throw new Error('Failed to create post - no data returned');

      const post = result.data;

      // Get author name from session or use simple query
      const enrichedPost = {
        ...post,
        author: {
          id: authorId,
          name: 'User',
          email: ''
        },
        upvote_count: 0,
        downvote_count: 0,
        is_marked_answer: false
      };

      cache.delete(`thread:${threadId}`);

      logger.info(`Post created: ${post.id} by user ${authorId}`);
      return { success: true, data: enrichedPost };
    } catch (error) {
      logger.error('Error creating post:', error);
      return { success: false, error: error.message };
    }
  }

  async votePost(postId, userId, voteType) {
    try {
      if (!postId || !userId) throw new Error('Missing required fields');
      if (!['upvote', 'downvote'].includes(voteType)) {
        throw new Error('Invalid vote type');
      }

      // Check XP requirement for downvote
      if (voteType === 'downvote') {
        const canDownvote = await this.checkXPRequirement(userId, 'downvote');
        if (!canDownvote) {
          return { success: false, error: 'You need 50 XP to downvote posts' };
        }
      }

      // Check daily limit
      const withinLimit = await this.checkDailyLimit(userId);
      if (!withinLimit) {
        return { success: false, error: 'Daily XP limit reached. Try again tomorrow.' };
      }

      // Get post author
      const { data: post } = await supabase
        .from('forum_posts')
        .select('author_id, thread_id')
        .eq('id', postId)
        .single();

      if (!post) throw new Error('Post not found');
      if (post.author_id === userId) {
        return { success: false, error: 'Cannot vote on your own post' };
      }

      // Check existing vote
      const { data: existing } = await supabase
        .from('forum_votes')
        .select('id, vote_type')
        .eq('post_id', postId)
        .eq('user_id', userId)
        .single();

      let action = null;
      let reputationChange = 0;

      if (existing) {
        if (existing.vote_type === voteType) {
          await supabase.from('forum_votes').delete().eq('id', existing.id);
          action = 'vote_removed';
          reputationChange = voteType === 'upvote' ? -10 : 5;
        } else {
          await supabase.from('forum_votes').update({ vote_type: voteType }).eq('id', existing.id);
          action = 'vote_changed';
          reputationChange = voteType === 'upvote' ? 20 : -20;
        }
      } else {
        await supabase.from('forum_votes').insert({ post_id: postId, user_id: userId, vote_type: voteType });
        action = 'vote_added';
        reputationChange = voteType === 'upvote' ? 10 : -5;
      }

      if (reputationChange !== 0) {
        await this.updateUserReputation(post.author_id, reputationChange);
        await this.logDailyXP(userId, Math.abs(reputationChange));
        await this.checkAndAwardBadges(post.author_id);
      }

      cache.delete(`thread:${post.thread_id}`);

      return { success: true, action, vote: action === 'vote_removed' ? null : voteType };
    } catch (error) {
      logger.error('Error voting on post:', error);
      return { success: false, error: error.message };
    }
  }

  async markAsAnswer(postId, threadId, userId) {
    try {
      if (!postId || !threadId || !userId) {
        throw new Error('Missing required fields');
      }

      // Verify user is thread creator
      const { data: thread } = await supabase
        .from('forum_threads')
        .select('creator_id, center_id')
        .eq('id', threadId)
        .single();

      if (!thread) throw new Error('Thread not found');
      if (thread.creator_id !== userId) {
        throw new Error('Only thread creator can mark answers');
      }

      // Unmark other answers
      await supabase
        .from('forum_posts')
        .update({ is_marked_answer: false })
        .eq('thread_id', threadId);

      // Mark this as answer
      const { error } = await supabase
        .from('forum_posts')
        .update({ is_marked_answer: true })
        .eq('id', postId);

      if (error) throw error;

      // Mark thread as solved
      await supabase
        .from('forum_threads')
        .update({ is_solved: true })
        .eq('id', threadId);

      logger.info(`Post ${postId} marked as answer in thread ${threadId}`);
      return { success: true };
    } catch (error) {
      logger.error('Error marking answer:', error);
      return { success: false, error: error.message };
    }
  }

  // ============================================
  // THREAD FOLLOWING
  // ============================================
  
  async followThread(threadId, userId) {
    try {
      const { error } = await supabase
        .from('forum_thread_followers')
        .insert({ thread_id: threadId, user_id: userId });

      if (error && error.code !== '23505') throw error;
      return { success: true };
    } catch (error) {
      logger.error('Error following thread:', error);
      return { success: false, error: error.message };
    }
  }

  async unfollowThread(threadId, userId) {
    try {
      await supabase
        .from('forum_thread_followers')
        .delete()
        .eq('thread_id', threadId)
        .eq('user_id', userId);

      return { success: true };
    } catch (error) {
      logger.error('Error unfollowing thread:', error);
      return { success: false, error: error.message };
    }
  }

  // ============================================
  // HELPER METHODS
  // ============================================
  
  generateSlug(title) {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 100) + '-' + Date.now().toString(36);
  }

  async recordThreadView(threadId, userId) {
    try {
      // Record view
      await supabase
        .from('forum_thread_views')
        .insert({ thread_id: threadId, user_id: userId });

      // Increment counter
      await supabase.rpc('increment', {
        table_name: 'forum_threads',
        row_id: threadId,
        column_name: 'view_count'
      });
    } catch (error) {
      // Silently fail
      logger.debug('View recording failed:', error.message);
    }
  }

  async notifyThreadFollowers(threadId, authorId, postId) {
    try {
      const { data: followers } = await supabase
        .from('forum_thread_followers')
        .select('user_id')
        .eq('thread_id', threadId)
        .eq('notify_on_reply', true)
        .neq('user_id', authorId);

      // Create notifications (implement based on your notification system)
      // This is a placeholder
      for (const follower of followers || []) {
        // await notificationService.create(follower.user_id, ...);
      }
    } catch (error) {
      logger.error('Error notifying followers:', error);
    }
  }

  async updateReputation(userId, centerId, action) {
    const points = {
      thread_created: 10,
      post_created: 5,
      answer_marked: 50,
      upvote_received: 2
    };

    try {
      await supabase.rpc('increment', {
        table_name: 'forum_user_reputation',
        row_id: userId,
        column_name: 'reputation_points',
        amount: points[action] || 0
      });
    } catch (error) {
      logger.debug('Reputation update failed:', error.message);
    }
  }

  async checkFollowing(threadId, userId) {
    if (!userId) return false;
    try {
      const { data } = await supabase
        .from('forum_thread_followers')
        .select('id')
        .eq('thread_id', threadId)
        .eq('user_id', userId)
        .maybeSingle();
      return !!data;
    } catch {
      return false;
    }
  }

  async updateUserReputation(userId, points) {
    try {
      const { data: existing } = await supabase
        .from('user_reputation')
        .select('total_xp, level')
        .eq('user_id', userId)
        .single();

      const newXP = (existing?.total_xp || 0) + points;
      const newLevel = Math.floor(newXP / 100) + 1;

      if (existing) {
        await supabase
          .from('user_reputation')
          .update({ total_xp: newXP, level: newLevel, updated_at: new Date().toISOString() })
          .eq('user_id', userId);
      } else {
        await supabase
          .from('user_reputation')
          .insert({ user_id: userId, total_xp: Math.max(0, newXP), level: newLevel });
      }

      logger.info(`User ${userId} reputation updated: ${points > 0 ? '+' : ''}${points} XP (Total: ${newXP}, Level: ${newLevel})`);
    } catch (error) {
      logger.error('Error updating reputation:', error);
    }
  }

  async checkXPRequirement(userId, action) {
    try {
      const { data: requirement } = await supabase
        .from('xp_requirements')
        .select('min_xp_required')
        .eq('action', action)
        .single();

      if (!requirement) return true;

      const { data: reputation } = await supabase
        .from('user_reputation')
        .select('total_xp')
        .eq('user_id', userId)
        .single();

      return (reputation?.total_xp || 0) >= requirement.min_xp_required;
    } catch {
      return true;
    }
  }

  async checkDailyLimit(userId) {
    try {
      const today = new Date().toISOString().split('T')[0];
      const { data } = await supabase
        .from('daily_xp_log')
        .select('xp_earned, actions_count')
        .eq('user_id', userId)
        .eq('date', today)
        .single();

      return !data || (data.xp_earned < 200 && data.actions_count < 50);
    } catch {
      return true;
    }
  }

  async logDailyXP(userId, xp) {
    try {
      const today = new Date().toISOString().split('T')[0];
      const { data: existing } = await supabase
        .from('daily_xp_log')
        .select('xp_earned, actions_count')
        .eq('user_id', userId)
        .eq('date', today)
        .single();

      if (existing) {
        await supabase
          .from('daily_xp_log')
          .update({ 
            xp_earned: existing.xp_earned + xp, 
            actions_count: existing.actions_count + 1 
          })
          .eq('user_id', userId)
          .eq('date', today);
      } else {
        await supabase
          .from('daily_xp_log')
          .insert({ user_id: userId, date: today, xp_earned: xp, actions_count: 1 });
      }
    } catch (error) {
      logger.error('Error logging daily XP:', error);
    }
  }

  async checkAndAwardBadges(userId) {
    try {
      const { data: reputation } = await supabase
        .from('user_reputation')
        .select('total_xp')
        .eq('user_id', userId)
        .single();

      const xp = reputation?.total_xp || 0;
      const badges = [];

      if (xp >= 100) badges.push('helpful_100');
      if (xp >= 500) badges.push('expert_500');
      if (xp >= 1000) badges.push('master_1000');

      for (const badge of badges) {
        await supabase
          .from('user_badges')
          .insert({ user_id: userId, badge_type: badge })
          .onConflict('user_id,badge_type')
          .ignore();
      }
    } catch (error) {
      logger.debug('Badge check failed:', error.message);
    }
  }

  async getLeaderboard(limit = 20) {
    try {
      const { data, error } = await supabase
        .from('forum_leaderboard')
        .select('*')
        .limit(limit);

      if (error) throw error;
      return { success: true, data: data || [] };
    } catch (error) {
      logger.error('Error getting leaderboard:', error);
      return { success: false, error: error.message, data: [] };
    }
  }

  async getUserBadges(userId) {
    try {
      const { data, error } = await supabase
        .from('user_badges')
        .select('badge_type, earned_at')
        .eq('user_id', userId)
        .order('earned_at', { ascending: false });

      if (error) throw error;
      return { success: true, data: data || [] };
    } catch (error) {
      logger.error('Error getting badges:', error);
      return { success: false, error: error.message, data: [] };
    }
  }
}

module.exports = new ForumService();

